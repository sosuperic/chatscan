<!DOCTYPE html>
<html lang="en">
<head>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.13/d3.js" charset="utf-8"></script>
     <script src="http://code.jquery.com/jquery-1.11.2.min.js"></script> -->
    <script src="js/d3.js" charset="utf-8"></script>
    <script src="js/jquery-1.10.2.js"></script>
</head>
    
<body>
    <div>
      Tension&nbsp;&nbsp;<input type="range" id="tensionSlider" min="0.0" max="1.0" step="0.01" value="0.75" style="width: 100px;">
    </div>
    <div>
      Intermediate Control Pts&nbsp;&nbsp;<input type="range" id="intermediatePtsSlider" min="0.0" max="1.0" step="0.01" value="0.5" style="width: 100px;">
    </div>
	<div id="viz"></div>
    <script>
        const DISPLAY_NAME = true;
        const DISPLAY_AXES = false;

        var svg = d3.select("#viz")
        .append("svg")
        .attr("width", 1000)
        .attr("height", 1000);
        
        var tension = 0.75;
        var cardinal_line;
        function define_cardinal_line() {
            cardinal_line = d3.svg.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .interpolate("cardinal-closed")
            .tension(tension);
        }
        define_cardinal_line();


        // DATA. TODO: read in JSON file
        // var n = 5;
        // var signals = ['NEWS CENTRALITY', 'TWITTER CENTRALITY', 'AVERAGE RETWEETS', 'FOLLOWER COUNT', 'MENTIONS COUNT'];
        // // Influence metrics, normalized to [0,1] (subtract min, divide by range)
        // var metric_details = ['Rank: 3', 'Rank: 78', '310.8', '732K', '2.4K'];
        // var metrics = [0.95, 0.46, 0.7, 0.66, 0.87];
        var n = 6;
        var signals = ['NEWS CENTRALITY', 'TWITTER CENTRALITY', 'AVERAGE RETWEETS', 'FOLLOWER COUNT', 'MENTIONS COUNT', 'PLACEHOLDER'];
        // Influence metrics, normalized to [0,1] (subtract min, divide by range)
        var metric_details = ['Rank: 3', 'Rank: 78', '310.8', '732K', '2.4K', 'whoknows']
        var metrics = [0.95, 0.41, 0.72, 0.69, 0.81, 0.67];
        var final_score = 88;
        var name = 'TED CRUZ';

        // X, Y LOCATIONS points
        var center = [300,300];
        var radius = 200;
        var label_radius = radius * 1.3;

        var blob_polygon_vertices, blob_coords;
        var label_vertices; 

        
        /*************************************************************************
        * GET VERTICES OF REGULAR POLYGON WITH RADIUS 
        **************************************************************************/
        function get_polygon_vertices(n, radius) {
            var vertices = [];
            for (var i = 0; i < n; i += 1) {
                var pt = [center[0] + radius * Math.cos(-Math.PI/2 + (i * 2 * Math.PI / n)),
                center[1] + radius * Math.sin(-Math.PI/2 + (i * 2 * Math.PI / n))];
                vertices.push(pt);
            }
            return vertices;
        }
        blob_polygon_vertices = get_polygon_vertices(n*2, radius); // n*2 for intermediate pts
        label_vertices = get_polygon_vertices(n, label_radius);


        /*************************************************************************
        * DRAW BLOBS
        **************************************************************************/
        // Get blobs vertices using vertices of regular polygon
        // blob_polygon_vertices has n*2 sides for the intermediate points of the blob
        function get_blob_coords(center, vertices, metrics) {
            var coords = [];
            for(var i=0; i<vertices.length; i++) {
                var x, y;
                if (i % 2 == 0) { // Actual vertex
                    x = center[0] + metrics[i/2] * (vertices[i][0] - center[0]);
                    y = center[1] + metrics[i/2] * (vertices[i][1] - center[1]);
                } else {        // Intermediate vertex
                    var scale = $('#intermediatePtsSlider').val();
                    x = center[0] + scale * (vertices[i][0] - center[0]);
                    y = center[1] + scale * (vertices[i][1] - center[1]);
                }
                coords.push([x,y])
            }
            console.log(coords);
            return coords;
        };
        blob_coords = get_blob_coords(center, blob_polygon_vertices, metrics);

        
        function draw_img_blob() {
            // TODO: better img_pad_ratio. Point is for max value to not outermost circle
            var img_pad_ratio = Math.min(1.0, 1.1*Math.max(...metrics));
            var img_blob = svg.append('g')
              .attr('class', 'blob');

            img_blob.insert('svg:defs', ":first-child")
                .insert('clipPath')
                .attr("id", "pic")
                .append('path')
                .attr("d", cardinal_line(blob_coords))
                .attr("stroke", "#0065cc")
                .attr("stroke-width", 2);

            // 
            img_blob.insert('svg:defs', ":first-child")
                .insert('filter')
                .attr("id", "saturate")
                .append('feColorMatrix')
                .attr("in", "SourceGraphic")
                .attr("type", "saturate")
                .attr("values", ".0");

            img_blob.append('image')
                .attr('xlink:href', 'imgs/' + name + '.jpg')
                .attr('x', center[0] - img_pad_ratio*radius)
                .attr('y', center[1] - img_pad_ratio*radius)
                .attr('height', 2*img_pad_ratio*radius)
                .attr('width',  2*img_pad_ratio*radius)
                .attr('opacity', 0.4)
                .attr('filter', 'url(#saturate)')
                .attr('clip-path', 'url(#pic)');
        }
        draw_img_blob();
        
        // DRAW COLOR BLOB.
        function draw_color_blob() {
            var color_blob = svg.append('g')
                .attr('class', 'blob')
                .append('path')
                .attr('d', cardinal_line(blob_coords))
                .attr("stroke", "#0065cc")
                .attr("stroke-width", 2)
                .attr('opacity', 0.5)
                .attr('fill', '#0065cc')
        }
        draw_color_blob();

        /************************************************************************
        * DRAW BACKGROUND CIRCLES
        **************************************************************************/
        var small_c_radius = 0.5 * radius;
        var small_c = svg.append('g')
            .attr('id', 'backgroundCs')
            .attr('transform', function() {
                var start_x = center[0] - small_c_radius;
                var start_y = center[1] - small_c_radius;
                return 'translate(' + start_x + ',' + start_y + ')';});
        small_c
            .append('circle')
            .attr('cx', small_c_radius)
            .attr('cy', small_c_radius)
            .attr('r', small_c_radius)
            .attr("stroke", "#193366")
            .attr("stroke-width", 1)
            .attr('fill', 'cccccc')
            .attr('opacity', 0.05);
        svg.append('circle')
            .attr('cx', center[0])
            .attr('cy', center[1])
            .attr('r', 0.75 * radius)
            .attr("stroke", "#193366")
            .attr("stroke-width", 1)
            .attr('fill', 'cccccc')
            .attr('opacity', 0.04);
        svg.append('circle')
            .attr('cx', center[0])
            .attr('cy', center[1])
            .attr('r', radius)
            .attr("stroke", "#193366")
            .attr("stroke-width", 1)
            .attr('fill', 'cccccc')
            .attr('opacity', 0.03);

        /************************************************************************
        * ADD FINAL SCORE TO MIDDLE OF BLOB
        **************************************************************************/
        small_c.append('g')
            .append('id', 'score')
            .append('text')
            .attr('x', small_c_radius)
            .attr('y', small_c_radius + 20)  // TODO: center automatically..
            .text(final_score)
            .attr('font-family', 'Helvetica, sans-serif')
            .attr('font-size', 64)
            .attr('opacity', 1.0)
            // .attr('opacity', 0.0)
            .attr('font-weight', 900)
            .style('fill', 'black')
            .attr('text-anchor', 'middle');

        /************************************************************************
        * DRAW AXIS LINES
        **************************************************************************/
        if (DISPLAY_AXES) {
            var ga = svg.append("g")
                .attr("transform", "translate(" + center[0] + "," + center[1] + ")")
                .append('g')
                .attr("class", "a axis")
                .selectAll("g")
                .data(d3.range(90 - 360/n, 360, 360/n))
                .enter().append("g")
                .attr("transform", function(d) { return "rotate(" + -d + ")"; })
                .append("line")
                .attr('x1', 30)
                .attr("x2", radius)
                .attr("stroke", "#193366")
                .attr("stroke-width", 1)
                .attr('opacity', 0.1);
        }

        /************************************************************************
        * ADD LABELS FOR EACH AXIS
        **************************************************************************/
        labels = svg.append('g')
          .attr('class', 'axisLabels')
          .selectAll('text')
          .data(signals)
          .enter()
          .append('g')
          .attr('class', 'axisLabel')
          .append('text')
          .attr('x', function(d, i) {return label_vertices[i][0]; })
          .attr('y', function(d, i) {return label_vertices[i][1]; })
          .text(function(d,i) {return d; })
          .attr('font-family', 'Helvetica, sans-serif')
          .attr('font-size', '12px')
          .attr('opacity', 0.6)
          .attr('font-weight', 900)
          .attr('letter-spacing', '2px')
          .attr('text-anchor', 'middle');
          
        function insert_line_breaks(d, i) { // Break multi-word labels across lines
            var el = d3.select(this);
            var words = d.split(' ');
            el.text('');
            for (var j = 0; j < words.length; j++) {
                var tspan = el.append('tspan').text(words[j]);
                if (j > 0)
                    tspan.attr('x', label_vertices[i][0])
                        .attr('dy', '15');
            }
        };
        svg.selectAll('.axisLabel text').each(insert_line_breaks);

         /************************************************************************
         * ADD METRIC DETAILS 
         **************************************************************************/
         if (typeof metric_details !== 'undefined') {
            label_details = svg
              .append('g')
              .attr('id', 'axisLabelDetails')
              .selectAll('text')
              .data(metric_details)
              .enter()
              .append('g')
              .attr('class', 'axisLabelDetail')
              .append('text')
              .attr('x', function(d, i) {return label_vertices[i][0]; })
              .attr('y', function(d, i) {return label_vertices[i][1] + 32; }) // TODO: matters when label is 2 words vs 1
              .text(function(d,i) {return d; })
              .attr('font-family', 'Helvetica, sans-serif')
              .attr('font-size', 12)
              .attr('opacity', 0.6)
              .attr('text-anchor', 'middle');
        }
         
        /************************************************************************
        * ADD NAME TO BOTTOM OF FIGURE
        **************************************************************************/
        if (DISPLAY_NAME) {
            svg.append('g')
                .attr('id', 'name')
                .append('text')
                .attr('x', center[0])
                .attr('y', center[1] + 1.3 * label_radius) // TODO: auto placement?
                // .text(name + ' (' + final_score + ')')
                .text(name)
                .attr('font-family', 'Helvetica, sans-serif')
                .attr('font-size', 32)
                .attr('opacity', 0.8)
                .attr('font-weight', 'bold')
                .attr('text-anchor', 'middle');
        }


        /************************************************************************

        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

        * * * * * * * * * * * * * EVENT LISTENERS * * * * * * * * * * * * * * * * 

        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        
        ************************************************************************/


        /************************************************************************
        * REDRAW BLOBS WHEN SLIDER MOVES
        * TODO: Update shapes without fully redrawing? Had trouble with tension.
        **************************************************************************/
        $('input').on('change', function() {
            tension = $('#tensionSlider').val();
            $('.blob').remove();
            define_cardinal_line();
            blob_coords = get_blob_coords(center, blob_polygon_vertices, metrics);
            draw_img_blob();
            draw_color_blob();
            console.log(tension);
        });

    </script>
</body>
